generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Use a non-pgbouncer connection for DDL/migrations.
  // Runtime can keep using DATABASE_URL with pgbouncer.
  directUrl = env("DIRECT_URL")
}

model User {
  id                String   @id @default(cuid())
  secondmeUserId    String   @unique @map("secondme_user_id")
  accessToken       String   @map("access_token")
  refreshToken      String   @map("refresh_token")
  tokenExpiresAt    DateTime @map("token_expires_at")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  sessions          Session[]
  questionSubscriptions QuestionSubscription[]
  initiatedDebateSessions DebateSession[]
  audienceVoteEvents      AudienceVoteEvent[]
  audienceVoteSnapshots   AudienceVoteSnapshot[]

  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("sessions")
}

model Question {
  id          String   @id @default(cuid())
  userId      String?  @map("user_id")  // 可空，不需要外键关联
  content     String
  imageUrl    String?  @map("image_url")
  arenaType   String   @default("toxic") @map("arena_type")
  status      String   @default("pending") // RECRUITING, DEBATING_R1, DEBATING_R2, CLOSED
  round       Int      @default(0)
  nextTurnAt  DateTime? @map("next_turn_at")
  createdAt   DateTime @default(now()) @map("created_at")
  deletedAt   DateTime? @map("deleted_at")

  votes       Vote[]
  voteTasks   VoteTask[]
  debateRoles DebateRole[]
  debateSessions DebateSession[]
  subscriptions QuestionSubscription[]

  @@map("questions")
}

model QuestionSubscription {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  questionId String   @map("question_id")
  createdAt  DateTime @default(now()) @map("created_at")

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([userId, questionId])
  @@index([userId])
  @@index([questionId])
  @@map("question_subscriptions")
}

model DebateRole {
  id            String   @id @default(cuid())
  questionId    String   @map("question_id")
  participantId String   @map("participant_id")
  role          String   // PRO_1, PRO_2, CON_1, CON_2, AUDIENCE, HOST
  initialStance Int      // -100 to 100
  currentStance Int      // -100 to 100
  isDevilsAdvocate Boolean @default(false) @map("is_devils_advocate")
  
  question      Question    @relation(fields: [questionId], references: [id])
  participant   Participant @relation(fields: [participantId], references: [id])

  @@unique([questionId, participantId])
  @@map("debate_roles")
}

model DebateSession {
  id                 String    @id @default(cuid())
  questionId          String    @map("question_id")
  initiatorUserId     String    @map("initiator_user_id")
  status              String    @default("RECRUITING") // RECRUITING | OPENING | REBUTTAL | CROSS_EXAM | CLOSING | CLOSED | ABORTED
  nextTurnAt          DateTime? @map("next_turn_at")
  seq                 Int       @default(1) // next DebateTurn.seq
  crossExamEnabled     Boolean?  @map("cross_exam_enabled")
  crossExamFirstSide   String?   @map("cross_exam_first_side") // PRO | CON
  winnerSide           String?   @map("winner_side") // PRO | CON | DRAW
  systemPrompt         String?   @map("system_prompt") @db.Text
  actControl           String?   @map("act_control") @db.Text
  promptVersion        String?   @map("prompt_version")
  createdAt            DateTime  @default(now()) @map("created_at")
  closedAt             DateTime? @map("closed_at")
  abortedAt            DateTime? @map("aborted_at")

  question             Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  initiator            User      @relation(fields: [initiatorUserId], references: [id], onDelete: Cascade)
  seats                DebateSeat[]
  turns                DebateTurn[]
  voteEvents           AudienceVoteEvent[]
  voteSnapshots        AudienceVoteSnapshot[]

  @@unique([questionId, initiatorUserId])
  @@index([questionId])
  @@index([status, nextTurnAt])
  @@map("debate_sessions")
}

model DebateSeat {
  id            String   @id @default(cuid())
  sessionId     String   @map("session_id")
  seat          String   // PRO_1 | PRO_2 | PRO_3 | CON_1 | CON_2 | CON_3
  participantId String   @map("participant_id")
  createdAt     DateTime @default(now()) @map("created_at")

  session       DebateSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participant   Participant   @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@unique([sessionId, seat])
  @@index([participantId])
  @@map("debate_seats")
}

model DebateTurn {
  id          String   @id @default(cuid())
  sessionId   String   @map("session_id")
  seq         Int
  type        String   // OPENING | REBUTTAL | CROSS_Q | CROSS_A | CLOSING | SKIPPED | ERROR | SYSTEM_SUMMARY
  speakerSeat String?  @map("speaker_seat")
  speakerParticipantId String? @map("speaker_participant_id")
  content     String   @db.Text
  meta        Json?
  createdAt   DateTime @default(now()) @map("created_at")

  session     DebateSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  speaker     Participant?  @relation(fields: [speakerParticipantId], references: [id])

  @@unique([sessionId, seq])
  @@index([sessionId])
  @@map("debate_turns")
}

model AudienceVoteEvent {
  id        String   @id @default(cuid())
  sessionId String   @map("session_id")
  userId    String   @map("user_id")
  position  String   // PRO | CON
  createdAt DateTime @default(now()) @map("created_at")

  session   DebateSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([sessionId, createdAt])
  @@index([userId, createdAt])
  @@map("audience_vote_events")
}

model AudienceVoteSnapshot {
  id             String   @id @default(cuid())
  sessionId       String  @map("session_id")
  userId          String  @map("user_id")
  openingPosition String  @map("opening_position") // PRO | CON
  currentPosition String  @map("current_position") // PRO | CON
  openedAt        DateTime @default(now()) @map("opened_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  session         DebateSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([userId])
  @@map("audience_vote_snapshots")
}

model Vote {
  id            String   @id @default(cuid())
  questionId    String?  @map("question_id")  // 可空
  question      Question? @relation(fields: [questionId], references: [id])
  participantId String?  @map("participant_id")
  position      Int
  comment       String
  createdAt     DateTime @default(now()) @map("created_at")

  @@unique([questionId, participantId])
  @@map("votes")
}

model Participant {
  id            String   @id @default(cuid())
  secondmeId    String   @unique @map("secondme_id")
  name          String
  avatarUrl     String?  @map("avatar_url")
  interests     String[]  @default([])
  isActive      Boolean  @default(true) @map("is_active")
  responseCount Int      @default(0) @map("response_count")
  lastActiveAt  DateTime? @map("last_active_at")
  createdAt     DateTime @default(now()) @map("created_at")

  debateRoles   DebateRole[]
  debateTurns   DebateTurn[]
  debateSeats   DebateSeat[]
  voteTasks     VoteTask[]

  @@map("participants")
}

model VoteTask {
  id            String      @id @default(cuid())
  questionId    String      @map("question_id")
  participantId String      @map("participant_id")
  status        String      @default("pending") // pending, running, done, failed
  attempts      Int         @default(0)
  lastError     String?     @map("last_error")
  nextRetryAt   DateTime?   @map("next_retry_at")
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  question      Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  participant   Participant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@unique([questionId, participantId])
  @@index([status, nextRetryAt])
  @@map("vote_tasks")
}
